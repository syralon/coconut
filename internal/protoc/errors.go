package protoc

import (
	"fmt"
	"net/http"
	"os"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/syralon/coconut/proto/syralon/coconut/errors"
)

type ErrorBuilder struct {
	pkg     string
	version string
	exe     string
}

func NewErrorBuilder(version string) *ErrorBuilder {
	var exe string
	if len(os.Args) > 0 {
		exe = os.Args[0]
	}
	return &ErrorBuilder{version: version, exe: exe}
}

func (b *ErrorBuilder) Build(plugin *protogen.Plugin) error {
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}
		if err := b.build(plugin, file); err != nil {
			return err
		}
	}
	return nil
}

func (b *ErrorBuilder) build(plugin *protogen.Plugin, file *protogen.File) error {
	if len(file.Enums) == 0 {
		return nil
	}
	errorEnums := b.extract(file)
	if len(errorEnums) == 0 {
		return nil
	}
	out := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+"_errors.pb.go", file.GoImportPath)
	out.P("// Code generated by protoc-gen-choco-errors. DO NOT EDIT.")
	out.P("// source: ", file.GeneratedFilenamePrefix+".proto")
	out.P(fmt.Sprintf("// %s: %s", b.exe, b.version))
	out.P("package ", file.GoPackageName)
	out.P()
	out.P("import \"fmt\"")
	out.P()
	if file.GoImportPath != "github.com/syralon/coconut/proto/syralon/coconut/errors" {
		out.P("import errorspb \"github.com/syralon/coconut/proto/syralon/coconut/errors\"")
		b.pkg = "errorspb."
	}
	for _, en := range errorEnums {
		if err := b.output(out, en); err != nil {
			return err
		}
	}
	return nil
}

func (b *ErrorBuilder) extract(file *protogen.File) []*errorEnum {
	errorEnums := make([]*errorEnum, 0, len(file.Enums))
	for _, en := range file.Enums {
		opts, _ := en.Desc.Options().(*descriptorpb.EnumOptions)
		if opts == nil {
			continue
		}
		v, _ := proto.GetExtension(opts, errors.E_AsError).(bool)
		if !v {
			continue
		}

		def, _ := proto.GetExtension(opts, errors.E_DefaultError).(*errors.ErrorOption)
		if def == nil {
			def = &errors.ErrorOption{Status: proto.Int32(int32(http.StatusInternalServerError))}
		}
		values := make([]*errorEnumValue, 0, len(en.Values))
		for _, val := range en.Values {
			opt, _ := val.Desc.Options().(*descriptorpb.EnumValueOptions)

			e := &errorEnumValue{
				EnumValue: val,
				goName:    string(en.Desc.Name()) + "_" + string(val.Desc.Name()),
				e:         b.extractError(opt, def),
			}
			values = append(values, e)
		}
		errorEnums = append(errorEnums, &errorEnum{
			Enum:   en,
			values: values,
		})
	}
	return errorEnums
}

func (b *ErrorBuilder) extractError(opt *descriptorpb.EnumValueOptions, def *errors.ErrorOption) *errors.ErrorOption {
	if opt == nil {
		return proto.CloneOf(def)
	}
	ce, _ := proto.GetExtension(opt, errors.E_Error).(*errors.ErrorOption)
	if ce == nil {
		return proto.CloneOf(def)
	}
	if ce.Message == nil {
		ce.Message = def.Message
	}
	return ce
}

func (b *ErrorBuilder) mapping(out *protogen.GeneratedFile, en *errorEnum, name, fnName string, ty string, fn func(value *errorEnumValue) (any, bool)) string {
	name = string(en.Desc.Name()) + "_" + name
	out.P("var ", name, "= map[", en.Desc.Name(), "]", ty, "{")
	for _, val := range en.values {
		vv, ok := fn(val)
		if !ok {
			continue
		}
		out.P(en.Desc.Name(), "_", val.Desc.Name(), ": ", vv, ",")
	}
	out.P("}\n")

	out.P("func (e ", en.Desc.Name(), ") ", fnName, "() ", ty, "{")
	out.P("    return ", name, "[e]")
	out.P("}")
	return name
}

func (b *ErrorBuilder) output(out *protogen.GeneratedFile, en *errorEnum) error {
	messages := b.mapping(out, en, "messages", "Message", "string", func(v *errorEnumValue) (any, bool) {
		if v.e.Message == nil {
			return "\"\"", false
		}
		return "\"" + v.e.GetMessage() + "\"", true
	})
	statuses := b.mapping(out, en, "statuses", "Status", "int32", func(v *errorEnumValue) (any, bool) {
		if v.e.Status == nil {
			return "0", false
		}
		return v.e.GetStatus(), true
	})
	b.outputFuncError(out, en, messages)
	b.outputFuncToError(out, en, messages, statuses)
	b.outputFuncUnwrap(out, en)
	return nil
}

func (b *ErrorBuilder) outputFuncError(out *protogen.GeneratedFile, en *errorEnum, messages string) {
	// Error
	out.P("// Error")
	out.P("// implemented error interface")
	out.P("func (e ", en.Desc.Name(), ") Error() string {")
	out.P("    return fmt.Sprintf(\"%d: %s\", e, ", messages, "[e])")
	out.P("}\n")
}

func (b *ErrorBuilder) outputFuncToError(out *protogen.GeneratedFile, en *errorEnum, messages, statuses string) {
	// ToError
	out.P("// ToError ")
	out.P("// convert to *errorspb.Error")
	out.P("func (e ", en.Desc.Name(), ") ToError() *", b.pkg, "Error {")
	out.P("    if _, ok := ", en.Desc.Name(), "_name[int32(e)]; ok {")
	out.P("        return &", b.pkg, "Error{")
	out.P("            Message: ", messages, "[e],")
	out.P("            Code: int32(e),")
	out.P("            StatusCode: ", statuses, "[e],")
	out.P("        }")
	out.P("    }")
	out.P("    return ", b.pkg, "New(", b.pkg, "CodeUnknown, \"unknown error\")")
	out.P("}\n")
}

func (b *ErrorBuilder) outputFuncUnwrap(out *protogen.GeneratedFile, en *errorEnum) {
	// Unwrap
	out.P("// Unwrap")
	out.P("// unwrap error")
	out.P("func (e ", en.Desc.Name(), ") Unwrap() error { return e.ToError() }\n")
}

type errorEnum struct {
	*protogen.Enum
	values []*errorEnumValue
}

type errorEnumValue struct {
	*protogen.EnumValue
	e      *errors.ErrorOption
	goName string
}
